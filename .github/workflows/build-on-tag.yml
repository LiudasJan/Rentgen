name: Build on Tag

on:
  push:
    tags:
      - '*'

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            arch: x64
          - os: ubuntu-latest
            arch: arm64
          - os: windows-latest
            arch: x64
          - os: windows-latest
            arch: arm64
          - os: macos-latest
            arch: arm64
          - os: macos-latest
            arch: x64

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '22'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build installers
        run: npm run make -- --arch=${{ matrix.arch }}

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: Rentgen-installers-${{ matrix.os }}-${{ matrix.arch }}
          path: |
            out/make/**
          retention-days: 30

  release:
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Download all artifacts
        uses: actions/download-artifact@v5
        with:
          path: artifacts

      - name: Extract tag name
        id: tag
        run: echo "TAG_NAME=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

      - name: Fetch all tags
        run: git fetch --tags

      - name: Generate release notes from CHANGELOG
        id: release_notes
        run: |
          TAG_NAME="${{ steps.tag.outputs.TAG_NAME }}"

          # Check if CHANGELOG.md exists
          if [ ! -f "CHANGELOG.md" ]; then
            echo "CHANGELOG.md not found, falling back to git commits"
            # Fallback to git commits
            git tag --sort=-version:refname > /tmp/all_tags.txt
            PREVIOUS_TAG=""
            while IFS= read -r tag; do
              if [ "$tag" != "$TAG_NAME" ]; then
                PREVIOUS_TAG="$tag"
                break
              fi
            done < /tmp/all_tags.txt

            if [ -z "$PREVIOUS_TAG" ]; then
              NOTES=$(git log ${TAG_NAME} --pretty=format:"- %s (%h)" --no-merges)
              COMPARE_URL="https://github.com/${{ github.repository }}/releases/tag/${TAG_NAME}"
            else
              NOTES=$(git log ${PREVIOUS_TAG}..${TAG_NAME} --pretty=format:"- %s (%h)" --no-merges)
              COMPARE_URL="https://github.com/${{ github.repository }}/compare/${PREVIOUS_TAG}...${TAG_NAME}"
            fi

            if [ -z "$NOTES" ]; then
              NOTES="No changes found"
            fi

            {
              echo "## What's Changed"
              echo ""
              echo "$NOTES"
              echo ""
              echo "**Full Changelog**: $COMPARE_URL"
            } > release_notes.md
            exit 0
          fi

          # Extract changelog entry for this version
          # Look for lines starting with ## [TAG_NAME] (e.g., ## [v1.2.0.9])
          CHANGELOG_ENTRY=""
          IN_SECTION=false

          # Escape special characters in tag for regex
          ESCAPED_TAG=$(echo "$TAG_NAME" | sed 's/\./\\./g')

          while IFS= read -r line || [ -n "$line" ]; do
            # Check if this is the start of our version section
            # Match pattern like: ## [v1.2.0.9] or ## [TAG_NAME]
            if echo "$line" | grep -qE "^## \[${ESCAPED_TAG}\]"; then
              IN_SECTION=true
              # Skip the header line itself, we'll use the content below
              continue
            fi

            # If we're in our section and hit another version header, stop
            if [ "$IN_SECTION" = true ]; then
              if echo "$line" | grep -qE "^## \["; then
                break
              fi
              # Add the line to our entry
              CHANGELOG_ENTRY="${CHANGELOG_ENTRY}${line}"$'\n'
            fi
          done < CHANGELOG.md

          # Trim trailing newlines and whitespace
          CHANGELOG_ENTRY=$(echo -n "$CHANGELOG_ENTRY" | sed -e :a -e '/^\n*$/{$d;N;ba' -e '}' | sed 's/[[:space:]]*$//')

          # Get previous tag for compare URL
          git tag --sort=-version:refname > /tmp/all_tags.txt
          PREVIOUS_TAG=""
          while IFS= read -r tag; do
            if [ "$tag" != "$TAG_NAME" ]; then
              PREVIOUS_TAG="$tag"
              break
            fi
          done < /tmp/all_tags.txt

          if [ -z "$PREVIOUS_TAG" ]; then
            COMPARE_URL="https://github.com/${{ github.repository }}/releases/tag/${TAG_NAME}"
          else
            COMPARE_URL="https://github.com/${{ github.repository }}/compare/${PREVIOUS_TAG}...${TAG_NAME}"
          fi

          # If we found changelog entry, use it; otherwise fallback to git commits
          # Check if CHANGELOG_ENTRY has meaningful content (not just whitespace)
          if [ -n "$CHANGELOG_ENTRY" ] && [ "$(echo "$CHANGELOG_ENTRY" | tr -d '[:space:]')" != "" ]; then
            {
              echo "$CHANGELOG_ENTRY"
              echo ""
              echo "**Full Changelog**: $COMPARE_URL"
            } > release_notes.md
            echo "Successfully extracted changelog entry for ${TAG_NAME}"
          else
            echo "No changelog entry found for ${TAG_NAME}, falling back to git commits"
            # Fallback to git commits
            if [ -z "$PREVIOUS_TAG" ]; then
              NOTES=$(git log ${TAG_NAME} --pretty=format:"- %s (%h)" --no-merges)
            else
              NOTES=$(git log ${PREVIOUS_TAG}..${TAG_NAME} --pretty=format:"- %s (%h)" --no-merges)
            fi

            if [ -z "$NOTES" ]; then
              NOTES="No changes found"
            fi

            {
              echo "## What's Changed"
              echo ""
              echo "$NOTES"
              echo ""
              echo "**Full Changelog**: $COMPARE_URL"
            } > release_notes.md
          fi

      - name: Rename installer files with platform prefixes
        run: |
          TAG_NAME="${{ steps.tag.outputs.TAG_NAME }}"
          echo "Renaming installer files to format: Rentgen-${TAG_NAME}-platform-arch.extension"

          # Rename DMG files (macOS): Rentgen-VERSION-ARCH.dmg -> Rentgen-TAG_NAME-mac-ARCH.dmg
          find artifacts -type f -name "Rentgen-*.dmg" | while read file; do
            dir=$(dirname "$file")
            basename=$(basename "$file")
            # Extract arch from filename (e.g., Rentgen-1.2.1-x64.dmg -> x64)
            arch=$(echo "$basename" | sed -n 's/.*-\(x64\|arm64\)\.dmg$/\1/p')
            if [ -n "$arch" ]; then
              newname="Rentgen-${TAG_NAME}-mac-${arch}.dmg"
              mv "$file" "$dir/$newname"
              echo "Renamed: $basename -> $newname"
            fi
          done

          # Rename EXE files (Windows): Rentgen VERSION Setup.exe -> Rentgen-TAG_NAME-win-ARCH.exe
          find artifacts -type f -name "*.exe" | while read file; do
            dir=$(dirname "$file")
            basename=$(basename "$file")
            # Extract arch from directory path (artifacts/Rentgen-installers-windows-latest-x64/...)
            # or filename, default to x64
            arch="x64"
            if echo "$file" | grep -qi "arm64"; then
              arch="arm64"
            fi
            newname="Rentgen-${TAG_NAME}-win-${arch}.exe"
            mv "$file" "$dir/$newname"
            echo "Renamed: $basename -> $newname"
          done

          # Rename DEB files (Linux): rentgen_VERSION_ARCH.deb -> Rentgen-TAG_NAME-linux-ARCH.deb
          find artifacts -type f -name "rentgen_*.deb" | while read file; do
            dir=$(dirname "$file")
            basename=$(basename "$file")
            # Extract arch from filename (e.g., rentgen_1.2.1_amd64.deb -> amd64)
            arch=$(echo "$basename" | sed -n 's/.*_\(amd64\|arm64\)\.deb$/\1/p')
            if [ -n "$arch" ]; then
              # Convert amd64 to x64 for consistency
              if [ "$arch" = "amd64" ]; then
                arch="x64"
              fi
              newname="Rentgen-${TAG_NAME}-linux-${arch}.deb"
              mv "$file" "$dir/$newname"
              echo "Renamed: $basename -> $newname"
            fi
          done

          # Rename RPM files (Linux): rentgen-VERSION-REVISION.ARCH.rpm -> Rentgen-TAG_NAME-linux-ARCH.rpm
          find artifacts -type f -name "rentgen-*.rpm" | while read file; do
            dir=$(dirname "$file")
            basename=$(basename "$file")
            # Extract arch from filename (e.g., rentgen-1.2.1-1.x86_64.rpm -> x86_64)
            # RPM uses x86_64 for x64 and aarch64 for ARM 64-bit
            arch=$(echo "$basename" | sed -n 's/.*\.\(x86_64\|aarch64\)\.rpm$/\1/p')
            if [ -n "$arch" ]; then
              # Convert x86_64 to x64, aarch64 to arm64 for consistency with other platforms
              if [ "$arch" = "x86_64" ]; then
                arch="x64"
              elif [ "$arch" = "aarch64" ]; then
                arch="arm64"
              fi
              newname="Rentgen-${TAG_NAME}-linux-${arch}.rpm"
              mv "$file" "$dir/$newname"
              echo "Renamed: $basename -> $newname"
            fi
          done

          echo "File renaming complete!"

      - name: Prepare installer files
        run: |
          # Find and list only installer files
          echo "Searching for installer files..."
          find artifacts -type f \( \
            -name "*.dmg" -o \
            -name "*.exe" -o \
            -name "*.deb" -o \
            -name "*.rpm" \
          \) > installer_files.txt || true

          if [ ! -s installer_files.txt ]; then
            echo "No installer files found! Listing artifacts directory:"
            find artifacts -type f | head -20
            exit 1
          fi

          echo "Found installer files:"
          cat installer_files.txt

          # Count files
          FILE_COUNT=$(wc -l < installer_files.txt)
          echo "Total installer files: $FILE_COUNT"

      - name: Delete existing release if present
        run: |
          TAG_NAME="${{ steps.tag.outputs.TAG_NAME }}"
          REPO="${{ github.repository }}"

          # Get release ID if it exists
          RESPONSE=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${REPO}/releases/tags/${TAG_NAME}" || echo "")

          RELEASE_ID=$(echo "$RESPONSE" | grep -o '"id":[0-9]*' | head -1 | cut -d':' -f2 || echo "")

          if [ -n "$RELEASE_ID" ]; then
            echo "Deleting existing release ${TAG_NAME} (ID: ${RELEASE_ID})"
            curl -X DELETE \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${REPO}/releases/${RELEASE_ID}"
            echo "Release deleted successfully"
          else
            echo "No existing release found for ${TAG_NAME}"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.tag.outputs.TAG_NAME }}
          name: Release ${{ steps.tag.outputs.TAG_NAME }}
          body_path: release_notes.md
          files: |
            artifacts/**/*.dmg
            artifacts/**/*.exe
            artifacts/**/*.deb
            artifacts/**/*.rpm
          fail_on_unmatched_files: false
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
